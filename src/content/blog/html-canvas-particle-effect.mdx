---
layout: ../../layouts/BlogLayout.astro
title: "HTML Canvas Particle Effect"
description: "Whether you want fancy effects on your website, or are developing a JavaScript game, particle effects can spice things up. In this tutorial you will learn how to create simple particle effects with plain JavaScript."
date: "December 2022"
tags: ["JavaScript", "Animations"]
backURL: "/b"
---

import Demo from "../../components/blog/particle-effect/demo.svelte";

# Particle Effect with JavaScript and HTML Canvas

Whether you want fancy effects on your website, or are developing a JavaScript
game, particle effects can spice things up. In this tutorial you will learn how
to create simple particle effects with plain JavaScript and the
[Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). This
tutorial requires some basic JavaScript knowledge, but is very beginner
friendly.

The full code for this tutorial is at the [end](#the-code) of this article.

## The Canvas

First we create the HTML `canvas` element and reference it in our JavaScript. We
give it a fixed height and width, in this case the size of our viewport. The
values will equal the pixels on the axes. You can style the canvas size with CSS
but this will just scale the rendered image and can distort your graphics. Then
we get the drawing context with `getContext()`.

```js
// html
<canvas id="myCanvas"></canvas>;

//js
const canvas = document.getElementById("myCanvas");
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;

const context = canvas.getContext("2d");
```

## The Particle

Now we create a particle `class`, which will be the template for our particle
objects. The constructor method will be passed a x- and y-coordinate. The
Particles in this tutorial will be circles so we also add a field r for the
radius in the constructor method.

```js
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 14;
  }
}

const p = new Particle(2, 4); // { x: 2, y: 4, r: 14 }
```

Next we create a class method draw that draws the particle on the canvas. You
can check out
[this useful tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes)
on how to draw different shapes.

```js
class Particle {
  // ...
  draw() {
    context.fillStyle = "salmon";
    context.beginPath();
    context.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    context.fill();
  }
}
```

Now that we are able to draw on the canvas, we can add an 'click' event listener
to the canvas element. We pass our mouse position coordinates from the event as
arguments when we create a new instance of our `Particle` class.

```js
function addParticle(ev) {
  const pa = new Particle(ev.x, ev.y);
  pa.draw();
}
canvas.addEventListener("click", addParticle);
```

Small note: If your canvas is not the size of your viewport, you have to get the
_relative_ position of your mouse. You can do something like this:

```js
function handleClick(ev) {
  const { left, top } = canvas.getBoundingClientRect();
  const relativeMousePosition = {
    x: ev.clientX - left,
    y: ev.clientY - top,
  };
}
```

Well done! We made our first particles.

<Demo stage="1" client:load />

## The Loop

Static circles aren't very interesting. We should add some animation to them.
For this we need an animation _loop_.

We could use `setInterval` or `setTimeout` but we want a ðŸ§ˆ-smooth animation that
matches the framerate of our device. This is where
[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
comes in. `requestAnimationFrame` accepts a callback function and requests that
this function is called before the browser performs the next repaint. To call it
again in the next _"frame"_ we will create our `loop` like this:

```js
function loop() {
  // we will draw our particles here

  // continue the loop
  window.requestAnimationFrame(loop);
}

// start the loop
window.requestAnimationFrame(loop);
```

_But wait, doesn't my animation speed now depend on the refresh rate of my
monitor?_

This is correct, but `requestAnimationFrame` gives you also the tool to time
your animation: a pretty
[precise timestamp](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp).
The `timestamp` is passed as the first argument to the callback function. We
will use this timestamp to calculate the `elapsedTime` since the last frame and
update our particles accordingly.

```js
let lastFrame = 0;

function loop(timestamp) {
  let elapsedTime = Math.min((timestamp - lastFrame) / 1000, 0.1);
  lastFrame = timestamp;

  // we will draw our particles here

  window.requestAnimationFrame(loop);
}
```

Because the `timestamp` is in milliseconds we divide by 1000 to calculate the
seconds that have passed since the last frame.

On more thing you should know about `requestAnimationFrame` is, that it will
pause once you minimize the browser window or go into another tab. This will
cause the `elapsedTime` to be so vast, that it will mess up your animations. The
`Math.min` ensures that the `elapsedTime` will not surpass `0.1`.

Now we will store our particle in an array, so we can iterate over them in our
loop function.

```js
let particles = [];

function loop(timestamp) {
  let elapsedTime = Math.min((timestamp - lastFrame) / 1000, 0.1);
  lastFrame = timestamp;

  for (const pa of particles) {
    pa.draw();
  }

  window.requestAnimationFrame(loop);
}

function addParticle(ev) {
  particles.push(new Particle(ev.x, ev.y));
}
```

_They are still static and and nothing moves ðŸ‘€._

That is because we don't update our particles yet. Let's add a `update` method
to the Particle class. It will reduce the particles radius `r` every frame:

```js
class Particle {
  // ...
  update(elapsedTime) {
    this.r -= elapsedTime + 0.2;
  }
}
```

Looks good, but there's actually a problem with this: A particles radius will
eventually be negative and this will cause an error in our draw method. To solve
this, we should remove particles whose radius has become smaller than or is
equal to 0.1. To remove the _drawings_ of the previous frame we also have to
clear the canvas every frame before we draw our updated particles. Our finished
`loop` looks like this:

```js
function loop(timestamp) {
  let elapsedTime = Math.min((timestamp - lastFrame) / 1000, 0.1);
  lastFrame = timestamp;

  // update all particles
  for (const pa of particles) {
    pa.update(elapsedTime);
  }

  // remove particles with radius <= 0.1
  particles = particles.filter((pt) => pt.r > 0.1);

  // clear canvas
  context.clearRect(0, 0, canvas.width, canvas.height);

  // draw all particles
  for (const pa of particles) {
    pa.draw();
  }

  // continue loop
  window.requestAnimationFrame(loop);
}
```

Great! We have our first animated particles ðŸŽ‰.

<Demo stage="2" client:load />

## The Effect

Now to the last part: We want to create a _small explosion_ of particles ðŸ’¥.

To move them in different direction the particles need a velocity. For this we
add the fields vx and vy to our Particle class. We will set some random values
so it doesn't look to stiff. We also change the radius to a random value to
create different sized particles.

At last we have to add the our velocities to our particles position in the
update method.

Our finished class looks like this:

```js
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vy = Math.random() * 300 - 150;
    this.vx = Math.random() * 300 - 150;
    this.r = Math.random() * 14 + 1;
  }
  draw() {
    context.fillStyle = "salmon";
    context.beginPath();
    context.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    context.fill();
  }
  update(elapsedTime) {
    this.x += this.vx * elapsedTime;
    this.y += this.vy * elapsedTime;
    this.r -= elapsedTime + 0.2;
  }
}
```

Now all we have to do is create a lot of particles when we click the canvas.

```js
function addParticle({ x, y }) {
  for (let i = 0; i < 60; i++) {
    particles.push(new Particle(x, y));
  }
}
```

Congrats! There you have a simple particle effect âœ¨.

<Demo stage="3" client:load />

## The Code

This is the whole code used in this tutorial. You can also check out this
[CodePen](https://codepen.io/AgathaKing/pen/oNExgvL).

```js
const canvas = document.getElementById("myCanvas");
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;

const context = canvas.getContext("2d");

let particles = [];
let lastFrame = 0;

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vy = Math.random() * 300 - 150;
    this.vx = Math.random() * 300 - 150;
    this.r = Math.random() * 14 + 1;
  }
  draw() {
    context.fillStyle = "salmon";
    context.beginPath();
    context.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    context.fill();
  }
  update(elapsedTime) {
    this.x += this.vx * elapsedTime;
    this.y += this.vy * elapsedTime;
    this.r -= elapsedTime + 0.2;
  }
}

function loop(timestamp) {
  let elapsedTime = Math.min((timestamp - lastFrame) / 1000, 0.1);
  lastFrame = timestamp;

  // update all particles
  for (const pa of particles) {
    pa.update(elapsedTime);
  }

  // remove particles with radius <= 0.1
  particles = particles.filter((pt) => pt.r > 0.1);

  // clear canvas
  context.clearRect(0, 0, canvas.width, canvas.height);

  // draw all particles
  for (const pa of particles) {
    pa.draw();
  }

  // continue loop
  window.requestAnimationFrame(loop);
}

// create 40 particles at mouse position
function addParticle({ x, y }) {
  for (let i = 0; i < 40; i++) {
    particles.push(new Particle(x, y));
  }
}
canvas.addEventListener("click", addParticle);

// start the loop
window.requestAnimationFrame(loop);
```
